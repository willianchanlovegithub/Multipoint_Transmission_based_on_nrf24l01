C51 COMPILER V9.59.0.0   NRE24L01                                                          09/26/2018 09:35:45 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE NRE24L01
OBJECT MODULE PLACED IN .\Objects\NRE24L01.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\NRE24L01.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\source) DE
                    -BUG OBJECTEXTEND PRINT(.\Listings\NRE24L01.lst) OBJECT(.\Objects\NRE24L01.obj)

line level    source

   1          
   2          #include <intrins.h>
   3          #include "NRF24L01.h"
   4          
   5          //uchar const TX_ADDRESS_P0[TX_ADR_WIDTH]= {0x77,0x35,0xF0,0xD3,0xE7}; //ͨ0ַдֽڣ
             -дֽSETUP_AWõַȵļĴ趨
   6          //uchar const RX_ADDRESS_P0[RX_ADR_WIDTH]= {0x77,0x35,0xF0,0xD3,0xE7}; //ͨ0յַдֽڣ
             -дֽSETUP_AWõַȵļĴ趨
   7          uchar const TX_ADDRESS_P1[TX_ADR_WIDTH]= {0xC2,0xC2,0xC2,0xC2,0xC2}; //ͨ1ַдֽڣд
             -ֽSETUP_AWõַȵļĴ趨
   8          uchar const RX_ADDRESS_P1[RX_ADR_WIDTH]= {0xC2,0xC2,0xC2,0xC2,0xC2}; //ͨ1յַдֽڣд
             -ֽSETUP_AWõַȵļĴ趨
   9          //uchar const TX_ADDRESS_P2[TX_ADR_WIDTH]= {0xC3,0xC2,0xC2,0xC2,0xC2}; //ͨ2ַдֽڣ
             -дֽSETUP_AWõַȵļĴ趨
  10          //uchar const RX_ADDRESS_P2[RX_ADR_WIDTH]= {0xC3,0xC2,0xC2,0xC2,0xC2}; //ͨ2յַдֽڣ
             -дֽSETUP_AWõַȵļĴ趨
  11          //uchar const TX_ADDRESS_P3[TX_ADR_WIDTH]= {0xC4,0xC2,0xC2,0xC2,0xC2}; //ͨ3ַдֽڣ
             -дֽSETUP_AWõַȵļĴ趨
  12          //uchar const RX_ADDRESS_P3[RX_ADR_WIDTH]= {0xC4,0xC2,0xC2,0xC2,0xC2}; //ͨ3յַдֽڣ
             -дֽSETUP_AWõַȵļĴ趨
  13          //uchar const TX_ADDRESS_P4[TX_ADR_WIDTH]= {0xC5,0xC2,0xC2,0xC2,0xC2}; //ͨ4ַдֽڣ
             -дֽSETUP_AWõַȵļĴ趨
  14          //uchar const RX_ADDRESS_P4[RX_ADR_WIDTH]= {0xC5,0xC2,0xC2,0xC2,0xC2}; //ͨ4յַдֽڣ
             -дֽSETUP_AWõַȵļĴ趨
  15          //uchar const TX_ADDRESS_P5[TX_ADR_WIDTH]= {0xC6,0xC2,0xC2,0xC2,0xC2}; //ͨ5ַдֽڣ
             -дֽSETUP_AWõַȵļĴ趨
  16          //uchar const RX_ADDRESS_P5[RX_ADR_WIDTH]= {0xC6,0xC2,0xC2,0xC2,0xC2}; //ͨ5յַдֽڣ
             -дֽSETUP_AWõַȵļĴ趨
  17          
  18          //********************ͻ*******************************
  19          uchar TxBuf[TX_PLOAD_WIDTH]={0};
  20          
  21          //********************************************************************************
  22          unsigned char bdata sta; //״̬־
  23          sbit RX_DR =sta^6;
  24          sbit TX_DS =sta^5;
  25          sbit MAX_RT =sta^4;
  26          
  27          
  28          //*********************ʱӺ************************
  29          void Delay10us()                //@11.0592MHz
  30          {
  31   1              unsigned char i;
  32   1      
  33   1              i = 2;
  34   1              while (--i);
  35   1      }
  36          
  37          
  38          void Delay100us()               //@11.0592MHz
  39          {
  40   1              unsigned char i;
  41   1      
  42   1              _nop_();
C51 COMPILER V9.59.0.0   NRE24L01                                                          09/26/2018 09:35:45 PAGE 2   

  43   1              i = 43;
  44   1              while (--i);
  45   1      }
  46          
  47          //************************************************
  48          unsigned char SPI_RW(unsigned char byte)
  49          {
  50   1              uchar bit_ctr;
  51   1              for(bit_ctr=0;bit_ctr<8;bit_ctr++)   // 8λ
  52   1              {
  53   2                      MOSI = (byte & 0x80);   // output 'byte', MSB to MOSI  byteλ
  54   2                      byte = (byte << 1);     // shift next bit into MSB..
  55   2                      SCK = 1;                                // Set SCK high..
  56   2                      byte |= MISO;                   // capture current MISO bit ôMISOõһλ
  57   2                      SCK = 0;                                // ..then set SCK low again
  58   2              }
  59   1              return(byte);                           // return read byte     󷵻شMISO                                
  60   1      }
  61          
  62          /********************************************************/
  63          unsigned char SPI_RW_Reg(unsigned char reg, unsigned char value)
  64          {
  65   1              uchar status;
  66   1              CSN = 0;              // CSN low, init SPI transaction
  67   1              status = SPI_RW(reg); //شMISO,statusӦΪϴüĴдvalue
  68   1              SPI_RW(value);        // and write value to it
  69   1              CSN = 1;                          // CSN high again
  70   1              return(status);       // return nRF24L01 status byte
  71   1      }
  72          
  73          /*************************ӻؼĴ*******************************/
  74          unsigned char SPI_Read(unsigned char reg)
  75          {
  76   1              uchar reg_val;
  77   1              CSN = 0;                     // CSN low, initialize SPI communication...
  78   1              SPI_RW(reg);         // Select register to read from..
  79   1              reg_val = SPI_RW(0); // ..then read registervalue
  80   1              CSN = 1;             // CSN high, terminate SPI communication
  81   1              return(reg_val);     // return register value
  82   1      }
  83          
  84          /********************************************************/
  85          //ָλöָȵ
  86          //reg:Ĵ(λ)
  87          //*pBuf:ָ
  88          //bytes:ݳ
  89          //ֵ,˴ζ״̬Ĵֵ 
  90          unsigned char SPI_Read_Buf(unsigned char reg, unsigned char *pBuf, unsigned char bytes)
  91          {
  92   1              uchar status,byte_ctr;
  93   1              CSN = 0; // ʹSPI
  94   1              status = SPI_RW(reg); // ͼĴֵ(λ),ȡ״ֵ̬           
  95   1              for(byte_ctr=0;byte_ctr<bytes;byte_ctr++)
  96   1                      pBuf[byte_ctr] = SPI_RW(0); // 
  97   1              CSN = 1; // رSPI
  98   1              return(status); // ض״ֵ̬
  99   1      }
 100          
 101          /**********************д**********************************/
 102          //ָλдָȵ
 103          //reg:Ĵ(λ)
 104          //*pBuf:ָ
C51 COMPILER V9.59.0.0   NRE24L01                                                          09/26/2018 09:35:45 PAGE 3   

 105          //bytes:ݳ
 106          //ֵ,˴ζ״̬Ĵֵ
 107          unsigned char SPI_Write_Buf(uchar reg, uchar *pBuf, uchar bytes)
 108          {
 109   1              uchar status,byte_ctr;
 110   1              CSN = 0; // Set CSN low, init SPI tranaction
 111   1              status = SPI_RW(reg); // Select register to write to and read status byte
 112   1              Delay10us();
 113   1              for(byte_ctr=0; byte_ctr<bytes; byte_ctr++) // then write all byte in buffer(*pBuf)
 114   1                      SPI_RW(*pBuf++);
 115   1              CSN = 1; // Set CSN high again
 116   1              return(status); // return nRF24L01 status byte
 117   1      }
 118          
 119          //24L01Ƿ
 120          //ַĴTX_ADDRɶҲдԿõַĴTX_ADDR֤һSPIͨǷдȥĺͶ
             -Ƿһ
 121          //ֵ:0ɹ;1ʧ
 122          uchar NRF24L01_Check(void)
 123          {
 124   1              uchar check_in_buf[5]={0x11,0x22,0x33,0x44,0x55};
 125   1              uchar check_out_buf[5]={0x00,0x00,0x00,0x00,0x00};
 126   1              
 127   1              SPI_Write_Buf(WRITE_REG + TX_ADDR , check_in_buf , 5);  //дcheck_in_bufĵַ
 128   1              SPI_Read_Buf(READ_REG + TX_ADDR , check_out_buf , 5);  //дĵַcheck_out_buf
 129   1              
 130   1              //Ƚcheck_in_bufcheck_out_bufǷһ
 131   1              if((check_out_buf[0] == 0x11)&&\
 132   1                 (check_out_buf[1] == 0x22)&&\
 133   1                 (check_out_buf[2] == 0x33)&&\
 134   1             (check_out_buf[3] == 0x44)&&\
 135   1             (check_out_buf[4] == 0x55))
 136   1                      return 0;//ȫһ£⵽24L01
 137   1              
 138   1          else 
 139   1                      return 1;//24L01
 140   1      }
 141          
 142          /********************Txģʽ******************/
 143          void TX_Mode(void)
 144          {
 145   1              CE=0;
 146   1              SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS_P1, TX_ADR_WIDTH); //дTXڵĵַͨ1
 147   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, RX_ADDRESS_P1, RX_ADR_WIDTH);//дRXڵĵַյַ
 148   1              
 149   1              //дòƲҪnRF24L01Ҳܹ͵ģΪʲôأ
 150   1      //      SPI_RW_Reg(WRITE_REG + EN_AA, 0x3F); // ͨ0ͨ1ͨ2ԶӦһգ
 151   1      //      SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x3F); //ͨ0ͨ1ͨ2һգ
 152   1              
 153   1              SPI_RW_Reg(WRITE_REG + SETUP_RETR, 0x1a); // Զطʱ500us + 86us,Զط10 
 154   1              SPI_RW_Reg(WRITE_REG + RF_CH, 40); //ùͨƵ
 155   1              SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x0f); // ÷2MHz书Ϊֵ0dB 
 156   1              SPI_RW_Reg(WRITE_REG + CONFIG,0x0e);//CRCʹܣ16λУ飬ϵ磬ģʽ
 157   1              CE=1;
 158   1      }
 159          
 160          //**********************NRF24L01ʼ*********************************/
 161          void init_NRF24L01(void)
 162          {
 163   1              Delay100us();
 164   1              CSN=1; // Spi disable
 165   1              SCK=0; // Spiʱ߳ʼ         
C51 COMPILER V9.59.0.0   NRE24L01                                                          09/26/2018 09:35:45 PAGE 4   

 166   1      }
 167          /****************************ڷӦź******************************/
 168          uchar CheckACK()
 169          {  
 170   1              sta=SPI_Read(STATUS);               // ״̬Ĵ
 171   1      //      if(TX_DS||MAX_RT)               //ж
 172   1              if(IRQ==0)
 173   1              {
 174   2                      SPI_RW_Reg(WRITE_REG+STATUS,0xff);  // TX_DSMAX_RTжϱ־
 175   2                      CSN=0;
 176   2                      SPI_RW(FLUSH_TX);//FIFO ؼȻ벻ĺҼס  
 177   2                      CSN=1; 
 178   2                      return(0);
 179   2              }
 180   1              else
 181   1                      return(1);
 182   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    371    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     43      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
