C51 COMPILER V9.59.0.0   NRF24L01                                                          08/21/2018 13:00:52 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE NRF24L01
OBJECT MODULE PLACED IN .\Objects\NRF24L01.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source\NRF24L01.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\sour
                    -ce) DEBUG OBJECTEXTEND PRINT(.\Listings\NRF24L01.lst) OBJECT(.\Objects\NRF24L01.obj)

line level    source

   1          
   2          #include <intrins.h>
   3          #include "NRF24L01.h"
   4          
   5          uchar const RX_ADDRESS_P0[TX_ADR_WIDTH]= {0x77,0x35,0xF0,0xD3,0xE7}; //ͨ0յַдֽڣд
             -ֽSETUP_AWõַȵļĴ趨
   6          uchar const RX_ADDRESS_P1[TX_ADR_WIDTH]= {0xC2,0xC2,0xC2,0xC2,0xC2}; //ͨ1յַдֽڣд
             -ֽSETUP_AWõַȵļĴ趨
   7          uchar const RX_ADDRESS_P2[1]= {0xC3}; //ͨ2յַдֽڣдֽSETUP_AWõַ
             -ȵļĴ趨ֻǵͰλͨ0ַһֻдͰλ
   8          uchar const RX_ADDRESS_P3[1]= {0xC4}; //ͨ3յַдֽڣдֽSETUP_AWõַ
             -ȵļĴ趨ֻǵͰλͨ0ַһֻдͰλ
   9          uchar const RX_ADDRESS_P4[1]= {0xC5}; //ͨ4յַдֽڣдֽSETUP_AWõַ
             -ȵļĴ趨ֻǵͰλͨ0ַһֻдͰλ
  10          uchar const RX_ADDRESS_P5[1]= {0xC6}; //ͨ5յַдֽڣдֽSETUP_AWõַ
             -ȵļĴ趨ֻǵͰλͨ0ַһֻдͰλ
  11          
  12          //********************ջ*******************************
  13          uchar RxBuf_P0[RX_PLOAD_WIDTH]={0};//ջ
  14          uchar RxBuf_P1[RX_PLOAD_WIDTH]={0};//ͨ1ջ
  15          uchar RxBuf_P2[RX_PLOAD_WIDTH]={0};//ͨ2ջ
  16          uchar RxBuf_P3[RX_PLOAD_WIDTH]={0};//ͨ3ջ
  17          uchar RxBuf_P4[RX_PLOAD_WIDTH]={0};//ͨ4ջ
  18          uchar RxBuf_P5[RX_PLOAD_WIDTH]={0};//ͨ5ջ
  19          
  20          //********************************************************************************
  21          unsigned char bdata sta; //״̬־
  22          sbit RX_DR =sta^6;
  23          sbit TX_DS =sta^5;
  24          sbit MAX_RT =sta^4;
  25          
  26          //*********************ʱӺ************************
  27          void Delay10us()                //@11.0592MHz
  28          {
  29   1              unsigned char i;
  30   1      
  31   1              i = 2;
  32   1              while (--i);
  33   1      }
  34          
  35          void Delay100us()               //@11.0592MHz
  36          {
  37   1              unsigned char i;
  38   1      
  39   1              _nop_();
  40   1              i = 43;
  41   1              while (--i);
  42   1      }
  43          
  44          //***********************************************************************
  45          unsigned char SPI_RW(unsigned char byte)
  46          {
  47   1              uchar bit_ctr;
  48   1              for(bit_ctr=0;bit_ctr<8;bit_ctr++)   // 8λ
C51 COMPILER V9.59.0.0   NRF24L01                                                          08/21/2018 13:00:52 PAGE 2   

  49   1              {
  50   2                      MOSI = (byte & 0x80);   //byteλ
  51   2                      byte = (byte << 1);     // shift next bit into MSB..
  52   2                      SCK = 1;                                // Set SCK high..
  53   2                      byte |= MISO;                   //ôMISOõһλ
  54   2                      SCK = 0;                                // ..then set SCK low again
  55   2              }
  56   1              return(byte);                           //󷵻شMISO                              
  57   1      }
  58          
  59          //SPIдĴ
  60          //reg:ָĴַ
  61          //value:дֵ
  62          unsigned char SPI_RW_Reg(unsigned char reg, unsigned char value)
  63          {
  64   1              uchar status;
  65   1              CSN = 0;              // ʹSPI
  66   1              status = SPI_RW(reg); //ͼĴ 
  67   1              SPI_RW(value);        //дĴֵ
  68   1              CSN = 1;                          // ֹSPI         
  69   1              return(status);       // ״ֵ̬
  70   1      }
  71          
  72          //ȡSPIĴֵ
  73          //reg:ҪļĴ
  74          unsigned char SPI_Read(unsigned char reg)
  75          {
  76   1              uchar reg_val;
  77   1              CSN = 0;                     // ʹSPI             
  78   1              SPI_RW(reg);         // ͼĴ
  79   1              reg_val = SPI_RW(0); // ȡĴ
  80   1              CSN = 1;             // ֹSPI     
  81   1              return(reg_val);     // ״ֵ̬
  82   1      }
  83          
  84          //ָλöָȵ
  85          //reg:Ĵ(λ)
  86          //*pBuf:ָ
  87          //bytes:ݳ
  88          //ֵ,˴ζ״̬Ĵֵ 
  89          unsigned char SPI_Read_Buf(unsigned char reg, unsigned char *pBuf, unsigned char bytes)
  90          {
  91   1              uchar status,byte_ctr;
  92   1              CSN = 0; // ʹSPI
  93   1              status = SPI_RW(reg); // ͼĴֵ(λ),ȡ״ֵ̬           
  94   1              for(byte_ctr=0;byte_ctr<bytes;byte_ctr++)
  95   1                      pBuf[byte_ctr] = SPI_RW(0); // 
  96   1              CSN = 1; // رSPI
  97   1              return(status); // ض״ֵ̬
  98   1      }
  99          
 100          //ָλдָȵ
 101          //reg:Ĵ(λ)
 102          //*pBuf:ָ
 103          //bytes:ݳ
 104          //ֵ,˴ζ״̬Ĵֵ
 105          unsigned char SPI_Write_Buf(uchar reg, uchar *pBuf, uchar bytes)
 106          {
 107   1              uchar status,byte_ctr;
 108   1              CSN = 0; // ʹSPI
 109   1              status = SPI_RW(reg); // ͼĴֵ(λ),ȡ״ֵ̬
 110   1              Delay10us();
C51 COMPILER V9.59.0.0   NRF24L01                                                          08/21/2018 13:00:52 PAGE 3   

 111   1              for(byte_ctr=0; byte_ctr<bytes; byte_ctr++) // д  
 112   1                      SPI_RW(*pBuf++);
 113   1              CSN = 1; //رSPI
 114   1              return(status); // ض״ֵ̬
 115   1      }
 116          
 117          //24L01Ƿ
 118          //ַĴTX_ADDRɶҲдԿõַĴTX_ADDR֤һSPIͨǷдȥĺͶ
             -Ƿһ
 119          //ֵ:0ɹ;1ʧ
 120          uchar NRF24L01_Check(void)
 121          {
 122   1              uchar check_in_buf[5]={0x11,0x22,0x33,0x44,0x55};
 123   1              uchar check_out_buf[5]={0x00,0x00,0x00,0x00,0x00};
 124   1              
 125   1              SPI_Write_Buf(WRITE_REG + TX_ADDR , check_in_buf , 5);  //дcheck_in_bufĵַ
 126   1              SPI_Read_Buf(READ_REG + TX_ADDR , check_out_buf , 5);  //дĵַcheck_out_buf
 127   1              
 128   1              //Ƚcheck_in_bufcheck_out_bufǷһ
 129   1              if((check_out_buf[0] == 0x11)&&\
 130   1                 (check_out_buf[1] == 0x22)&&\
 131   1                 (check_out_buf[2] == 0x33)&&\
 132   1             (check_out_buf[3] == 0x44)&&\
 133   1             (check_out_buf[4] == 0x55))
 134   1                      return 0;//ȫһ£⵽24L01
 135   1              
 136   1          else 
 137   1                      return 1;//24L01
 138   1      }
 139          
 140          //жǷյ
 141          //յ1ûյ0
 142          //uchar NRFRevDate(uchar *RevDate)
 143          //{
 144          //      uchar RevFlags=0;
 145          //      sta=SPI_Read(STATUS);//ݺȡ״̬Ĵ
 146          //  if(RX_DR)                           // жǷյ
 147          //      {
 148          //              CE=0;                   //SPIʹ
 149          //              SPI_Read_Buf(RD_RX_PLOAD,RevDate,RX_PLOAD_WIDTH);// RXFIFOȡ
 150          //              RevFlags=1;        //ȡɱ־
 151          //              CE=1;
 152          //              SPI_RW_Reg(WRITE_REG+STATUS,0xff); //յݺRX_DR,TX_DS,MAX_PTøΪ1ͨд1жϱ
 153          //              CSN=0;
 154          //              SPI_RW(FLUSH_RX);
 155          //              CSN=1;
 156          //      }
 157          //      return(RevFlags);
 158          //}
 159          /**********************NRF24L01ʼ*********************************/
 160          void init_NRF24L01(void)
 161          {       
 162   1              Delay100us();
 163   1              CSN=1; // SPIƬѡȡ           
 164   1              SCK=0; // Spi clock line init high
 165   1      }
 166          
 167          //úʼNRF24L01RXģʽ
 168          //RXַ,дRXݿ,ѡRFƵ,ʺLNA HCURR
 169          //CEߺ,RXģʽ,Խ      
 170          void RX_Mode(void)
 171          {
C51 COMPILER V9.59.0.0   NRF24L01                                                          08/21/2018 13:00:52 PAGE 4   

 172   1              //NRFΪģʽ
 173   1              CE=0;
 174   1              
 175   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, RX_ADDRESS_P0, RX_ADR_WIDTH);//дRXڵַͨ0
 176   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P1, RX_ADDRESS_P1, RX_ADR_WIDTH);//дRXڵַͨ1
 177   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P2, RX_ADDRESS_P2, 1);//дRXڵַͨ2
 178   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P3, RX_ADDRESS_P3, 1);//дRXڵַͨ3
 179   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P4, RX_ADDRESS_P4, 1);//дRXڵַͨ4
 180   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P5, RX_ADDRESS_P5, 1);//дRXڵַͨ5
 181   1              
 182   1              SPI_RW_Reg(WRITE_REG + EN_AA, 0x3F); // ͨ0~5ԶӦ
 183   1              SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x3F); //ͨ0~5
 184   1              
 185   1              SPI_RW_Reg(WRITE_REG + RX_PW_P0, RX_PLOAD_WIDTH);//ѡͨ0Чݿ
 186   1              SPI_RW_Reg(WRITE_REG + RX_PW_P1, RX_PLOAD_WIDTH);//ѡͨ1Чݿ
 187   1              SPI_RW_Reg(WRITE_REG + RX_PW_P2, RX_PLOAD_WIDTH);//ѡͨ2Чݿ
 188   1              SPI_RW_Reg(WRITE_REG + RX_PW_P3, RX_PLOAD_WIDTH);//ѡͨ3Чݿ
 189   1              SPI_RW_Reg(WRITE_REG + RX_PW_P4, RX_PLOAD_WIDTH);//ѡͨ4Чݿ
 190   1              SPI_RW_Reg(WRITE_REG + RX_PW_P5, RX_PLOAD_WIDTH);//ѡͨ5Чݿ
 191   1              
 192   1              SPI_RW_Reg(WRITE_REG + RF_CH, 40); //ùͨƵ
 193   1              SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x0f);//÷÷2MHz书Ϊֵ0dB
 194   1              SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f); //CRCʹܣ16λУ飬ϵ磬ģʽ 
 195   1              
 196   1              CE = 1; //CEøߣģʽ
 197   1      }
 198          
 199          //ͨѡӦĽջRxBuf_P0~RxBuf_P5
 200          uchar Rx_Pipe_Num_Choose(void)
 201          {
 202   1          uchar state;
 203   1          state=SPI_Read(STATUS);                     //ȡ״̬Ĵֵ
 204   1          SPI_RW_Reg(WRITE_REG + STATUS,state); //TX_DSMAX_RTжϱ־
 205   1          if(state&0x40)                                                              //յ
 206   1          {
 207   2              CE = 0;  //
 208   2              switch(state&0X0E) 
 209   2                      {
 210   3                              case 0x00:
 211   3                                      SPI_Read_Buf(RD_RX_PLOAD,RxBuf_P0,RX_PLOAD_WIDTH);
 212   3                                      break;                  //ȡͨ0
 213   3                              case 0x02:
 214   3                                      SPI_Read_Buf(RD_RX_PLOAD,RxBuf_P1,RX_PLOAD_WIDTH);
 215   3                                      break;                  //ȡͨ1
 216   3                              case 0x04:
 217   3                                      SPI_Read_Buf(RD_RX_PLOAD,RxBuf_P2,RX_PLOAD_WIDTH);
 218   3                                      break;                  //ȡͨ2
 219   3                              case 0x06:
 220   3                                      SPI_Read_Buf(RD_RX_PLOAD,RxBuf_P3,RX_PLOAD_WIDTH);
 221   3                                      break;                  //ȡͨ3
 222   3                              case 0x08:
 223   3                                      SPI_Read_Buf(RD_RX_PLOAD,RxBuf_P4,RX_PLOAD_WIDTH);
 224   3                                      break;                  //ȡͨ4
 225   3                              case 0x0A:
 226   3                                      SPI_Read_Buf(RD_RX_PLOAD,RxBuf_P5,RX_PLOAD_WIDTH);
 227   3                                      break;                  //ȡͨ5
 228   3              }
 229   2              SPI_RW_Reg(FLUSH_RX,0xff);                                      //RX FIFOĴ
 230   2              CE = 1;
 231   2              Delay100us();
 232   2              return 0;
 233   2          }
C51 COMPILER V9.59.0.0   NRF24L01                                                          08/21/2018 13:00:52 PAGE 5   

 234   1              else
 235   1                      return 1;  //ûյκ
 236   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    600    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =    206      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
